#! /usr/bin/env python
import sys
import threading
from bsddb import btopen
from pygr.seqdb import BlastDB
from SimpleXMLRPCServer import SimpleXMLRPCServer
from SocketServer import ThreadingMixIn
from cPickle import loads
import time
from ConfigParser import SafeConfigParser

host = None
port = None
done = False

class ZoundsCentral(object):
    def __init__(self, config_obj, section_name):
        self.section_name = section_name
        self.chunksize = config_obj.getint(section_name, 'chunksize')
        self.n_chunks = config_obj.getint(section_name, 'n_chunks')
        self.dump_frequency = config_obj.getint(section_name, 'dump_frequency')
        self.fasta_file = config_obj.get(section_name, 'sequences')
        self.db_file = config_obj.get(section_name, 'store_db')
        self.against_db_name = config_obj.get(section_name, 'blastdb')
        self.blast_program = config_obj.get(section_name, 'program')
        self.extra_blast_args = config_obj.get(section_name, 'blast_options')
        self.filter = config_obj.get(section_name, 'filter')

        print 'opening sequences:', self.fasta_file
        self.sequences = BlastDB(self.fasta_file)

        print 'opening database:', self.db_file
        self.db = btopen(self.db_file, 'c')

        self._undone = set()
        self._dbcache = dict()

        self.retrieve_lock = threading.Lock()

        print 'calculating undone seqs...',
        self._calc_undone()
        print '%d undone' % (len(self._undone),)

    def _calc_undone(self):
        db_keys = set(self.db.keys())
        fasta_keys = set([k for k in self.sequences ])
        self._undone = fasta_keys.difference(db_keys)

        self._undone_initial_count = len(self._undone)
        self._undone_current_count = self._undone_initial_count

    def save_cache_to_disk(self):
        keys = self._dbcache.keys()
        if not keys:
            return

        db = self.db
        _dbcache = self._dbcache

        for k in keys:
            db[k] = _dbcache[k]
            del _dbcache[k]

        self._undone_current_count -= len(keys)
        print 'saved %d from cache to disk, leaving %d' % (len(keys),
                                                  self._undone_current_count)

        db.sync()

    def estimate_undone(self):
        return self._undone_current_count

    def get_parameters(self):
        return (self.chunksize, self.n_chunks, self.dump_frequency,
                self.filter)

    def retrieve_sequences(self, chunksize):
        _undone = self._undone
        if not _undone:
            return ()

        self.retrieve_lock.acquire()

        try:
            i = iter(_undone)
            z = []
            for k in range(chunksize):
                try:
                    z.append(i.next())
                except StopIteration:
                    break

            print 'returning %d sequences' % (len(z),)

            seqs = [ (k, str(self.sequences[k])) for k in z ]
            _undone.difference_update(z)

            print '...%d undone' % (len(_undone))

            return (self.blast_program,
                    self.against_db_name,
                    self.extra_blast_args,
                    seqs)
        finally:
            self.retrieve_lock.release()

    def deposit_results(self, results):
        for k in results:
            print k[0], loads(k[1].data)
            self._dbcache[k[0]] = k[1].data

        print 'deposited %d' % (len(results),)

        return ()

def cache_saver(obj):
    while not done:
        obj.save_cache_to_disk()
        time.sleep(1)

###

def load_config(filename, section_name):
    global host, port

    fp = open(filename)
    
    config_obj = SafeConfigParser()
    config_obj.readfp(fp)

    host = config_obj.get(section_name, 'host')
    port = config_obj.getint(section_name, 'port')

    return config_obj

####

####

class ThreadedServer(ThreadingMixIn, SimpleXMLRPCServer):
    pass

def create_server(host, port, obj):

    # Create server
    server = ThreadedServer((host, port))
    server.register_function(obj.get_parameters, 'get_parameters')
    server.register_function(obj.retrieve_sequences, 'retrieve_sequences')
    server.register_function(obj.deposit_results, 'deposit_results')
    server.register_function(obj.estimate_undone, 'estimate_undone')

    return server

####

if __name__ == '__main__':
    config_file, section_name = sys.argv[1], sys.argv[2]
    config_obj = load_config(config_file, section_name)

    central = ZoundsCentral(config_obj, section_name)

    assert host is not None
    assert port

    saver_thread = threading.Thread(target=cache_saver, args=(central,))
    saver_thread.start()

    server = create_server(host, port, central)
    try:
        print 'serving %s on port %s...' % (section_name, port)
        server.serve_forever()
    except KeyboardInterrupt:
        done = True
        print 'waiting for saver thread to finish...'
        saver_thread.join()
        central.save_cache_to_disk()
        central.db.close()
